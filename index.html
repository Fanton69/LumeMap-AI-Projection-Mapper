
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#050505">
  <title>LumeMap - AI Projection Mapper</title>
  
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: #000; color: #fff; margin: 0; overflow: hidden; user-select: none; touch-action: none; }
    #error-display { position: fixed; bottom: 0; left: 0; right: 0; background: rgba(220, 38, 38, 0.95); color: white; padding: 20px; font-family: monospace; z-index: 9999; display: none; font-size: 13px; max-height: 40vh; overflow: auto; border-top: 2px solid white; }
    .loading-screen { display: flex; height: 100vh; flex-direction: column; align-items: center; justify-content: center; background: #050505; transition: opacity 0.5s; z-index: 1000; position: fixed; inset: 0; }
    .spinner { width: 40px; height: 40px; border: 3px solid rgba(99, 102, 241, 0.1); border-top-color: #6366f1; border-radius: 50%; animation: spin 0.8s linear infinite; margin-bottom: 20px; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>

  <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@19.0.0",
    "react-dom": "https://esm.sh/react-dom@19.0.0",
    "react-dom/client": "https://esm.sh/react-dom@19.0.0/client",
    "lucide-react": "https://esm.sh/lucide-react@0.460.0",
    "@google/genai": "https://esm.sh/@google/genai@1.3.0",
    "react/": "https://esm.sh/react@^19.2.3/"
  }
}
</script>

  <script>
    // Setup environment
    window.process = { env: { API_KEY: "" } };
    
    // Global Error Catcher
    window.onerror = function(msg, url, line, col, error) {
      const display = document.getElementById('error-display');
      if (display) {
        display.style.display = 'block';
        display.innerHTML += `<div><strong>Runtime Error:</strong> ${msg} <br><small>at ${line}:${col}</small></div><hr style="opacity:0.2;margin:10px 0">`;
      }
      return false;
    };
  </script>
</head>
<body>
  <div id="root"></div>
  <div class="loading-screen" id="initial-loader">
    <div class="spinner"></div>
    <div style="font-size: 10px; font-weight: 900; letter-spacing: 0.3em; color: #6366f1; text-transform: uppercase;">LumeMap Readying...</div>
  </div>
  <div id="error-display"></div>
  
  <script type="text/babel" data-presets="react,typescript" data-type="module">
    import React, { useState, useEffect, useRef } from 'react';
    import ReactDOM from 'react-dom/client';
    import { 
      Square, Trash2, Camera, Sparkles, Plus, 
      Circle, X, MonitorOff, Zap, Bot, Loader2, Maximize
    } from 'lucide-react';
    import { GoogleGenAI, Type } from "@google/genai";

    // --- TYPES ---
    type Point = { x: number; y: number };
    type Shape = {
      id: string;
      name: string;
      points: Point[];
      color: string;
      opacity: number;
      effect: string;
      visible: boolean;
    };

    // --- GEMINI SERVICE ---
    const generateMappingAI = async (prompt: string) => {
      const apiKey = process.env.API_KEY;
      if (!apiKey) throw new Error("API Key missing");
      const ai = new GoogleGenAI({ apiKey });
      const response = await ai.models.generateContent({
        model: 'gemini-3-pro-preview',
        contents: `Projection mapping request: ${prompt}`,
        config: {
          systemInstruction: "Generate JSON shapes for projection mapping. Coordinates 0.0-1.0. Effects: none, strobe, breathe, rainbow.",
          responseMimeType: "application/json",
          responseSchema: {
            type: Type.OBJECT,
            properties: {
              shapes: {
                type: Type.ARRAY,
                items: {
                  type: Type.OBJECT,
                  properties: {
                    name: { type: Type.STRING },
                    points: {
                      type: Type.ARRAY,
                      items: {
                        type: Type.OBJECT,
                        properties: { x: { type: Type.NUMBER }, y: { type: Type.NUMBER } },
                        required: ["x", "y"]
                      }
                    },
                    color: { type: Type.STRING },
                    effect: { type: Type.STRING }
                  },
                  required: ["name", "points", "color", "effect"]
                }
              }
            },
            required: ["shapes"]
          }
        }
      });
      return JSON.parse(response.text.trim());
    };

    // --- MAIN APP ---
    const App = () => {
      const [shapes, setShapes] = useState<Shape[]>([]);
      const [selectedId, setSelectedId] = useState<string | null>(null);
      const [mode, setMode] = useState<'IDLE' | 'DRAWING'>('IDLE');
      const [drawingPoints, setDrawingPoints] = useState<Point[]>([]);
      const [cameraOn, setCameraOn] = useState(false);
      const [showAI, setShowAI] = useState(false);
      const [loadingAI, setLoadingAI] = useState(false);
      const [zenMode, setZenMode] = useState(false);

      const canvasRef = useRef<HTMLCanvasElement>(null);
      const videoRef = useRef<HTMLVideoElement>(null);

      useEffect(() => {
        if (cameraOn) {
          navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
            .then(s => { if (videoRef.current) videoRef.current.srcObject = s; })
            .catch(err => console.error("Camera Error:", err));
        } else if (videoRef.current?.srcObject) {
          (videoRef.current.srcObject as MediaStream).getTracks().forEach(t => t.stop());
        }
      }, [cameraOn]);

      const getPos = (e: any): Point => {
        if (!canvasRef.current) return { x: 0, y: 0 };
        const rect = canvasRef.current.getBoundingClientRect();
        const touch = e.touches?.[0] || e;
        return {
          x: (touch.clientX - rect.left) / rect.width,
          y: (touch.clientY - rect.top) / rect.height
        };
      };

      const addShape = (pts: Point[], name = 'Surface') => {
        const newShape: Shape = {
          id: Math.random().toString(36).substr(2, 9),
          name: `${name} ${shapes.length + 1}`,
          points: pts,
          color: '#ffffff',
          opacity: 1,
          effect: 'none',
          visible: true
        };
        setShapes(prev => [...prev, newShape]);
        setSelectedId(newShape.id);
      };

      const handleStart = (e: any) => {
        const pos = getPos(e);
        if (mode === 'DRAWING') {
          const newPts = [...drawingPoints, pos];
          if (newPts.length > 2 && Math.hypot(pos.x - newPts[0].x, pos.y - newPts[0].y) < 0.05) {
            addShape(drawingPoints, 'Poly');
            setDrawingPoints([]);
            setMode('IDLE');
          } else {
            setDrawingPoints(newPts);
          }
          return;
        }
        
        // Simple hit test
        const hit = shapes.find(s => {
          const xs = s.points.map(p => p.x);
          const ys = s.points.map(p => p.y);
          return pos.x >= Math.min(...xs) && pos.x <= Math.max(...xs) &&
                 pos.y >= Math.min(...ys) && pos.y <= Math.max(...ys);
        });
        setSelectedId(hit?.id || null);
      };

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        
        let rid: number;
        const draw = (t: number) => {
          canvas.width = canvas.offsetWidth;
          canvas.height = canvas.offsetHeight;
          const { width: w, height: h } = canvas;
          ctx.clearRect(0, 0, w, h);

          if (cameraOn && videoRef.current) {
            ctx.globalAlpha = 0.4;
            ctx.drawImage(videoRef.current, 0, 0, w, h);
          }

          shapes.forEach(s => {
            if (!s.visible) return;
            ctx.save();
            let alpha = s.opacity;
            if (s.effect === 'breathe') alpha *= 0.6 + 0.4 * Math.sin(t / 400);
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            s.points.forEach((p, i) => i === 0 ? ctx.moveTo(p.x * w, p.y * h) : ctx.lineTo(p.x * w, p.y * h));
            ctx.closePath();
            ctx.fillStyle = s.color;
            ctx.fill();
            if (selectedId === s.id && !zenMode) {
              ctx.strokeStyle = '#6366f1';
              ctx.lineWidth = 3;
              ctx.stroke();
              // Points
              ctx.fillStyle = "#fff";
              s.points.forEach(p => {
                ctx.beginPath(); ctx.arc(p.x * w, p.y * h, 4, 0, 7); ctx.fill();
              });
            }
            ctx.restore();
          });

          if (mode === 'DRAWING' && drawingPoints.length > 0) {
            ctx.strokeStyle = '#6366f1';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            drawingPoints.forEach((p, i) => i === 0 ? ctx.moveTo(p.x * w, p.y * h) : ctx.lineTo(p.x * w, p.y * h));
            ctx.stroke();
          }
          rid = requestAnimationFrame(draw);
        };
        rid = requestAnimationFrame(draw);
        return () => cancelAnimationFrame(rid);
      }, [shapes, selectedId, mode, drawingPoints, cameraOn, zenMode]);

      return (
        <div className="h-screen w-screen bg-black overflow-hidden flex flex-col text-white touch-none">
          <video ref={videoRef} autoPlay playsInline muted className="hidden" />
          
          {!zenMode && (
            <div className="absolute top-8 left-8 right-8 flex justify-between items-center z-50">
              <div className="flex gap-4 p-2 bg-zinc-900/90 backdrop-blur rounded-2xl border border-white/10 shadow-2xl">
                <button onClick={() => addShape([{x:0.4,y:0.4},{x:0.6,y:0.4},{x:0.6,y:0.6},{x:0.4,y:0.6}], 'Quad')} className="p-3 hover:bg-white/10 rounded-xl transition-colors"><Square className="w-5 h-5"/></button>
                <button onClick={() => setMode('DRAWING')} className={`p-3 rounded-xl transition-all ${mode === 'DRAWING' ? 'bg-indigo-600' : 'hover:bg-white/10'}`}><Plus className="w-5 h-5"/></button>
                <button onClick={() => setCameraOn(!cameraOn)} className={`p-3 rounded-xl transition-all ${cameraOn ? 'text-green-400 bg-green-400/10' : 'hover:bg-white/10'}`}><Camera className="w-5 h-5"/></button>
              </div>
              <div className="flex gap-4">
                <button onClick={() => setShowAI(true)} className="px-6 py-3 bg-indigo-600 hover:bg-indigo-500 rounded-2xl font-bold text-[10px] uppercase tracking-widest flex items-center gap-2 shadow-xl active:scale-95 transition-all"><Sparkles className="w-4 h-4"/> AI Assist</button>
                <button onClick={() => setZenMode(true)} className="p-3 bg-zinc-900/90 rounded-2xl border border-white/10 hover:bg-white/5 transition-all"><Maximize className="w-5 h-5"/></button>
              </div>
            </div>
          )}

          <div className="flex-1 relative">
            <canvas ref={canvasRef} onPointerDown={handleStart} className="w-full h-full cursor-crosshair" />
            
            {selectedId && !zenMode && (
              <div className="absolute bottom-10 left-1/2 -translate-x-1/2 bg-zinc-900/95 border border-white/10 p-6 rounded-3xl flex items-center gap-6 backdrop-blur shadow-2xl animate-in slide-in-from-bottom-4">
                <input type="color" className="w-10 h-10 rounded-lg bg-transparent border-none cursor-pointer" onChange={e => {
                  setShapes(prev => prev.map(s => s.id === selectedId ? {...s, color: e.target.value} : s));
                }} />
                <select className="bg-black border border-white/10 rounded-lg p-2 text-[10px] font-black uppercase tracking-widest outline-none focus:ring-1 ring-indigo-500" onChange={e => {
                  setShapes(prev => prev.map(s => s.id === selectedId ? {...s, effect: e.target.value} : s));
                }}>
                  <option value="none">Static</option>
                  <option value="breathe">Breathe</option>
                  <option value="strobe">Strobe</option>
                </select>
                <button onClick={() => { setShapes(prev => prev.filter(s => s.id !== selectedId)); setSelectedId(null); }} className="p-3 text-red-400 hover:bg-red-400/10 rounded-xl transition-all"><Trash2 className="w-5 h-5"/></button>
              </div>
            )}
          </div>

          {showAI && (
            <div className="fixed inset-0 z-[100] bg-black/90 backdrop-blur-xl flex items-center justify-center p-6">
              <div className="bg-zinc-900 border border-white/10 w-full max-w-md rounded-[32px] p-8 shadow-2xl relative animate-in zoom-in-95">
                 <button onClick={() => setShowAI(false)} className="absolute top-6 right-6 p-2 text-zinc-500 hover:text-white"><X/></button>
                 <h2 className="text-xl font-black mb-4 flex items-center gap-2"><Sparkles className="text-indigo-400"/> AI Mapping</h2>
                 <textarea id="ai-p" placeholder="Describe layout (e.g. 5 random triangles)..." className="w-full h-24 bg-black border border-white/10 rounded-xl p-4 mb-4 text-sm focus:ring-1 ring-indigo-500 outline-none resize-none" />
                 <button disabled={loadingAI} onClick={async () => {
                   const prompt = (document.getElementById('ai-p') as any).value;
                   if (!prompt) return;
                   setLoadingAI(true);
                   try {
                     const res = await generateMappingAI(prompt);
                     res.shapes.forEach((s: any) => addShape(s.points, s.name));
                     setShowAI(false);
                   } catch (e) { alert("AI Error: " + e.message); } finally { setLoadingAI(false); }
                 }} className="w-full py-4 bg-indigo-600 rounded-xl font-bold uppercase tracking-widest flex items-center justify-center gap-2 shadow-lg hover:bg-indigo-500 transition-all">
                   {loadingAI ? <Loader2 className="animate-spin"/> : 'Generate Surfaces'}
                 </button>
              </div>
            </div>
          )}

          {zenMode && (
            <button onClick={() => setZenMode(false)} className="fixed top-8 right-8 p-4 bg-zinc-900/40 rounded-xl text-[10px] font-bold uppercase tracking-widest border border-white/10 opacity-0 hover:opacity-100 transition-all">Exit View</button>
          )}
        </div>
      );
    };

    // --- MOUNTING ---
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
    
    // Cleanup loader
    const loader = document.getElementById('initial-loader');
    if (loader) {
      setTimeout(() => {
        loader.style.opacity = '0';
        setTimeout(() => loader.remove(), 500);
      }, 500);
    }
  </script>
</body>
</html>
